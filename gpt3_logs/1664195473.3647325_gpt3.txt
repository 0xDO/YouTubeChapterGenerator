The following is an unstructured video transcript by David Shapiro. Please rewrite this as a more structured, clear essay.

TRANSCRIPT: heuristic imperative service reduced suffering to reduce suffering in this situation we should rescue the dog from the river so just this example which i just wrote by hand gives you a little bit of idea as to like what one single thought is going to look like here's another one 456.789 camera service visual input i see two men playing chess in a large park that looks like central park in new york city again this gives you just one sentence um you know one or two sentences per log gives you enough information to kind of understand what's going on um 987.654 executive action action decision i'm going to walk to the store to buy milk again very simple um and and what's going to ultimately happen is that the nexus is going to hold tens of thousands millions billions of records like this all in chronological order from different services it's all going to be compiled together into a single source all right so recap of this first section maragi is a star topology or also called hub and spoke centered around the nexus the nexus is functionally a syslog server or database there's all kinds of ways to implement that as long as it is searchable that is the key thing as long as it is searchable and it allows for some fields principles of microservice so i mentioned microservices it's a microservices architecture so what is a microservice and why do we use them at the highest level a microservice is a way to break a large complex piece of software into smaller more manageable components so rather than build one monolithic piece of software we're going to build it in as a service oriented architecture or a microservices architecture so microservices are good for parallel processing meaning that you can have different pieces all running in parallel with no dependencies on each other which means that they can keep running even if one fails you can replace it which is really good for resiliency so for instance let's say you've got you know your your machine running and then one service drops off you can have a supervisor that restarts that service or fixes it or says hey pause we're missing a service without the whole thing crashing um another big advantage of a microservices architecture is it allows for the system to grow over time without re-architecting the whole thing and that's why we have the star topology is because you just add new microservices and they all talk to the nexus via a standard interface which allows you to grow meragi over time without having to change anything meaning if you come up with a new micro service that you need to add you just add that in or if you need to swap one out you say hey we're going from version one to version two of a given microservice you just swap it out without it nothing else breaks which is another reason that you have to have standard data formats such as timestamp uuid content so it doesn't matter where it comes from as long as the log follows the correct format then everything will be fine as long as you have that standard format okay microservices form a network so this is talking kind of more generally about microservices they can be in any number of topologies such as a mesh star ring or bus um so this this graphic here is how a mesh topology might work where everything is kind of interconnected as a web i chose the star topology because it is by far the simplest layout um i did try other topologies um earlier in this in this project back in 2018 and 2019 and trust me hub and spoke is the easiest trying to create feed forward networks or mesh networks with this is really really complex um let's see there are different kinds of ways for them to interact so you can do rest you can do amqp you can do graphql you can do all kinds of things there's also the possibility that we can just use orchestration engines which kind of have their own internal apis but we'll get to that we'll figure out the correct way or the best way to implement it later on personally i prefer microservices because they can be written in any language and they and and they're very small and they don't they don't rely upon like a big uh platform and you don't have to worry about getting locked into any particular orchestration engine so i would prefer to stick with microservices but there are orchestration engines out there that could also be used to implement meraki all right so there's a few basic rules that i've already figured out and established for microservices for meragi specifically so the number one rule is microservices only talk to the nexus they don't talk to each other directly the nexus is the common broker for all messages so anything that they need to say goes into the nexus and then ever because the nexus is the single source of truth for all thoughts all microservices also pull from the nexus another the second rule is that they have to listen for the conductor we'll go over the conductor in just a minute but the conductor provides feedback and cognitive control to all the other microservices to steer everything um the mic number rule number three is the microservices must be auto didactic meaning they learn on their own sorry i've got something in my eye um they learn on their own um by observing their own behavior and observing the feedback that they get from the from the conductor so we'll go over how to create auto didactic services in the future basically it's a machine learning pipelining problem which is nothing new it's just a matter of integrating large language models into those machine learning pipelines they should use a combination of prompt prompt chaining and fine tuning eventually we'll probably just do all fine tuning although i can't say for certain each micro service runs as an infinite loop so basically it will periodically check the nexus for messages do its own work and then maybe add a message and then it'll go back to sleep and then wait again but it can change its tempo it can change its cycle rate based on feedback from the conductor

CLEAR ESSAY:

==========

The heuristic imperative service is designed to reduce suffering in situations where it is possible to do so. In this particular case, the dog should be rescued from the river.

This example demonstrates how a single thought would be logged in the system. Each log would consist of one or two sentences describing the action taken or the situation observed.

The Nexus is the central component of the Maragi system. It is functionally a syslog server or database, able to store and chronologically order vast quantities of data from different services.

Microservices are a way of breaking large, complex software systems into smaller, more manageable components. They are good for parallel processing and allow for system growth over time without the need for re-architecting the whole system.

In the Maragi system, microservices form a network, with the Nexus at the center. This topology is known as a star topology, or hub-and-spoke. It is the simplest layout and allows for easy growth of the system over time.

There are a few basic rules that have been established for microservices in the Maragi system. The first rule is that microservices can only talk to the Nexus; they cannot talk to each other directly. The Nexus is the common broker for all messages, so anything that needs to be communicated must go through the Nexus. The second rule is that microservices must listen for the conductor. The conductor provides feedback and cognitive control to all the other microservices in the system, steering them in the right direction. The third rule is that microservices must be auto didactic, meaning they learn on their own by observing their own behavior and the feedback they receive from the conductor.

Each microservice in the Maragi system runs as an infinite loop. It periodically checks the Nexus for messages, does its own work, and then maybe adds a message before going back to sleep and waiting again. However, the microservice can change its tempo or cycle rate based on feedback from the conductor.